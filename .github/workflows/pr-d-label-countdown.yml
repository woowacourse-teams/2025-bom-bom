name: Daily PR D-label Countdown (D-0 Discord Notify)

on:
  schedule:
    # ë§¤ì¼ ì˜¤ì „ 9ì‹œ(Asia/Seoul) = ë§¤ì¼ 00:00(UTC)
    - cron: "0 0 * * *"
  workflow_dispatch: {}

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  countdown_and_notify:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Decrement D-* labels on open PRs + Build D-0 Discord payload
        id: build
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // ê´€ë¦¬ ë²”ìœ„: D-0 ~ D-5
            const MIN = 0;
            const MAX = 5;
            const dLabelRegex = /^D-(\d+)$/;

            // Discord ID ë§¤í•‘ ë¡œë“œ (key normalize: ì†Œë¬¸ì)
            const rawMapping = JSON.parse(fs.readFileSync(".github/notification_ids.json", "utf8"));
            const discordIdByLogin = Object.fromEntries(
              Object.entries(rawMapping).map(([login, discordId]) => [String(login).toLowerCase(), String(discordId)])
            );

            function mentionOf(login) {
              const id = discordIdByLogin[String(login).toLowerCase()];
              return id ? `<@${id}>` : "";
            }

            // ì˜¤í”ˆ PR ì „ë¶€ ê°€ì ¸ì˜¤ê¸°
            const pulls = await github.paginate(github.rest.pulls.list, {
              owner,
              repo,
              state: "open",
              per_page: 100,
            });

            const becameD0 = [];

            // 1) D-label ì°¨ê°
            for (const pr of pulls) {
              const labels = (pr.labels || [])
                .map(l => (typeof l === "string" ? l : l.name))
                .filter(Boolean);

              const dLabels = labels
                .map(name => {
                  const m = name.match(dLabelRegex);
                  if (!m) return null;
                  const n = Number(m[1]);
                  if (Number.isNaN(n)) return null;
                  if (n < MIN || n > MAX) return null;
                  return { name, n };
                })
                .filter(Boolean);

              if (dLabels.length === 0) continue;

              dLabels.sort((a, b) => b.n - a.n);
              const current = dLabels[0].n;

              if (current <= MIN) continue;

              const next = current - 1;
              const nextLabel = `D-${next}`;

              for (const dl of dLabels) {
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: pr.number,
                    name: dl.name,
                  });
                } catch (e) {}
              }

              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: pr.number,
                labels: [nextLabel],
              });

              if (next === 0) {
                becameD0.push({
                  number: pr.number,
                  title: pr.title,
                  url: pr.html_url,
                  author: pr.user?.login ?? "unknown",
                });
              }
            }

            if (becameD0.length === 0) {
              core.setOutput("should_notify", "false");
              console.log("No PR reached D-0 today.");
              return;
            }

            // íŒ€ ë©¤ë²„ í›„ë³´: notification_ids.json ê¸°ì¤€
            const teamMembers = Object.keys(discordIdByLogin); // lowercased

            let content = "ğŸŒ¸ ì˜¤ëŠ˜ D-0 ë„ì°©í•œ PRì´ì—ìš”! ì§€ê¸ˆ í™•ì¸í•˜ë©´ ë”± ì¢‹ì•„ìš”\n";

            // 2) D-0 ë„ë‹¬ PRë³„ë¡œ ë©˜ì…˜/ë¬¸êµ¬ êµ¬ì„±
            for (const pr of becameD0) {
              const prNumber = pr.number;
              const authorLogin = String(pr.author).toLowerCase();

              const { data: reviews } = await github.rest.pulls.listReviews({
                owner,
                repo,
                pull_number: prNumber,
                per_page: 100,
              });

              // ë¦¬ë·°ì–´ë³„ ë§ˆì§€ë§‰ ìƒíƒœ
              const latestByUser = new Map();
              reviews
                .filter(r => r.user && r.user.login && r.submitted_at)
                .sort((a, b) => new Date(a.submitted_at) - new Date(b.submitted_at))
                .forEach(r => {
                  latestByUser.set(String(r.user.login).toLowerCase(), String(r.state));
                });

              let approvedCount = 0;
              let hasChangesRequested = false;

              for (const state of latestByUser.values()) {
                if (state === "APPROVED") approvedCount += 1;
                if (state === "CHANGES_REQUESTED") hasChangesRequested = true;
              }

              // ê¸°ë³¸ í›„ë³´: íŒ€ì› - author
              const candidates = teamMembers.filter(m => m !== authorLogin);

              // "ë¯¸ìŠ¹ì¸ì" = ì•„ì§ APPROVED ì•„ë‹Œ ì‚¬ëŒ(ë¦¬ë·° ì•ˆí–ˆê±°ë‚˜ COMMENTED í¬í•¨)
              const pendingReviewers = candidates.filter(login => {
                const latestState = latestByUser.get(login);
                return latestState !== "APPROVED";
              });

              // ë©˜ì…˜ ëŒ€ìƒ ì¡°í•©
              const mentionSet = new Set();

              // (A) ìˆ˜ì •ìš”ì²­ ìˆìœ¼ë©´ ì‘ì„±ì í˜¸ì¶œì€ í•­ìƒ í¬í•¨
              if (hasChangesRequested) {
                const m = mentionOf(authorLogin);
                if (m) mentionSet.add(m);
              }

              // (B) ìŠ¹ì¸ ë¶€ì¡±(<2)ì´ë©´ ë¯¸ìŠ¹ì¸ìë“¤ë„ í˜¸ì¶œ
              if (approvedCount < 2) {
                for (const login of pendingReviewers) {
                  const m = mentionOf(login);
                  if (m) mentionSet.add(m);
                }
              } else {
                // (C) ìŠ¹ì¸ 2ëª… ì´ìƒì´ë©´ "ë¨¸ì§€" ìœ ë„ -> ì‘ì„±ì í˜¸ì¶œ(ë§¤í•‘ ìˆìœ¼ë©´)
                const m = mentionOf(authorLogin);
                if (m) mentionSet.add(m);
              }

              const mentions = Array.from(mentionSet).join(" ");

              // ìƒíƒœ í…ìŠ¤íŠ¸ ê²°ì •(ìš°ì„ ìˆœìœ„: ìˆ˜ì •ìš”ì²­ > ë¨¸ì§€ ê°€ëŠ¥ > ë¦¬ë·° í•„ìš”)
              let statusText = "";
              if (hasChangesRequested && approvedCount < 2) {
                statusText = `ğŸ› ï¸ ìˆ˜ì • ìš”ì²­ ìˆìŒ + ğŸ‘€ ì¶”ê°€ ë¦¬ë·° í•„ìš” (í˜„ì¬ ìŠ¹ì¸ ${approvedCount}ëª…)`;
              } else if (hasChangesRequested && approvedCount >= 2) {
                statusText = `ğŸ› ï¸ ìˆ˜ì • ìš”ì²­ ìˆìŒ (í˜„ì¬ ìŠ¹ì¸ ${approvedCount}ëª…)`;
              } else if (!hasChangesRequested && approvedCount >= 2) {
                statusText = `âœ… ë¨¸ì§€ ê°€ëŠ¥ (í˜„ì¬ ìŠ¹ì¸ ${approvedCount}ëª…)`;
              } else {
                statusText = `ğŸ‘€ ë¦¬ë·° í•„ìš” (í˜„ì¬ ìŠ¹ì¸ ${approvedCount}ëª…)`;
              }

              const mentionPrefix = mentions ? `${mentions} ` : "";

              content += `\n- ${mentionPrefix}**${statusText}**\n  ${pr.title}\n  ${pr.url}\n`;
            }

            fs.writeFileSync("payload.json", JSON.stringify({ content }, null, 2), "utf8");
            core.setOutput("should_notify", "true");
            core.setOutput("d0_count", String(becameD0.length));

      - name: Notify Discord (D-0 reached PRs)
        if: steps.build.outputs.should_notify == 'true'
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          curl -sS -H "Content-Type: application/json" -d @payload.json "$DISCORD_WEBHOOK_URL"

name: Daily PR D-label Countdown (D-0 Discord Notify)

on:
  schedule:
    # ë§¤ì¼ ì˜¤ì „ 10ì‹œ(Asia/Seoul) = ë§¤ì¼ 01:00(UTC)
    - cron: "0 1 * * *"
  workflow_dispatch: {}

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  countdown_and_notify:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Decrement D-* labels on open PRs + Build D-0 Discord payload
        id: build
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // ê´€ë¦¬ ë²”ìœ„: D-0 ~ D-5
            const MIN = 0;
            const MAX = 5;
            const dLabelRegex = /^D-(\d+)$/;

            // Discord ID ë§¤í•‘ ë¡œë“œ (key normalize: ì†Œë¬¸ì)
            const rawMapping = JSON.parse(fs.readFileSync(".github/notification_ids.json", "utf8"));
            const discordIdByLogin = Object.fromEntries(
              Object.entries(rawMapping).map(([login, discordId]) => [String(login).toLowerCase(), String(discordId)])
            );

            function mentionOf(login) {
              const id = discordIdByLogin[String(login).toLowerCase()];
              return id ? `<@${id}>` : "";
            }

            // ì˜¤í”ˆ PR ì „ë¶€ ê°€ì ¸ì˜¤ê¸°
            const pulls = await github.paginate(github.rest.pulls.list, {
              owner,
              repo,
              state: "open",
              per_page: 100,
            });

            const becameD0 = [];

            // 1) D-label ì°¨ê°
            for (const pr of pulls) {
              const labels = (pr.labels || [])
                .map(l => (typeof l === "string" ? l : l.name))
                .filter(Boolean);

              const dLabels = labels
                .map(name => {
                  const m = name.match(dLabelRegex);
                  if (!m) return null;
                  const n = Number(m[1]);
                  if (Number.isNaN(n)) return null;
                  if (n < MIN || n > MAX) return null;
                  return { name, n };
                })
                .filter(Boolean);

              if (dLabels.length === 0) continue;

              dLabels.sort((a, b) => b.n - a.n);
              const current = dLabels[0].n;

              if (current <= MIN) continue;

              const next = current - 1;
              const nextLabel = `D-${next}`;

              for (const dl of dLabels) {
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: pr.number,
                    name: dl.name,
                  });
                } catch (e) {}
              }

              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: pr.number,
                labels: [nextLabel],
              });

              if (next === 0) {
                becameD0.push({
                  number: pr.number,
                  title: pr.title,
                  url: pr.html_url,
                  author: pr.user?.login ?? "unknown",
                });
              }
            }

            if (becameD0.length === 0) {
              core.setOutput("should_notify", "false");
              console.log("No PR reached D-0 today.");
              return;
            }

            // íŒ€ ë©¤ë²„ í›„ë³´: notification_ids.json ê¸°ì¤€
            const teamMembers = Object.keys(discordIdByLogin); // lowercased

            const embeds = [];
            
            for (const pr of becameD0) {
              const prNumber = pr.number;
              const authorLogin = String(pr.author).toLowerCase();
            
              const { data: reviews } = await github.rest.pulls.listReviews({
                owner,
                repo,
                pull_number: prNumber,
                per_page: 100,
              });
            
              const latestByUser = new Map();
              reviews
                .filter(r => r.user && r.user.login && r.submitted_at)
                .sort((a, b) => new Date(a.submitted_at) - new Date(b.submitted_at))
                .forEach(r => {
                  latestByUser.set(String(r.user.login).toLowerCase(), String(r.state));
                });
            
              let approvedCount = 0;
              let hasChangesRequested = false;
            
              for (const state of latestByUser.values()) {
                if (state === "APPROVED") approvedCount += 1;
                if (state === "CHANGES_REQUESTED") hasChangesRequested = true;
              }
            
              const candidates = teamMembers.filter(m => m !== authorLogin);
            
              const pendingReviewers = candidates.filter(login => {
                const latestState = latestByUser.get(login);
                return latestState !== "APPROVED";
              });
            
              const mentionSet = new Set();
            
              if (hasChangesRequested) {
                const m = mentionOf(authorLogin);
                if (m) mentionSet.add(m);
              }
            
              if (approvedCount < 2) {
                for (const login of pendingReviewers) {
                  const m = mentionOf(login);
                  if (m) mentionSet.add(m);
                }
              } else {
                const m = mentionOf(authorLogin);
                if (m) mentionSet.add(m);
              }
            
              const mentions = Array.from(mentionSet).join(" ");
            
              let statusText = "";
              if (hasChangesRequested && approvedCount < 2) {
                statusText = `ğŸ› ï¸ ìˆ˜ì • ìš”ì²­ ìˆìŒ + ğŸ‘€ ì¶”ê°€ ë¦¬ë·° í•„ìš” (í˜„ì¬ ìŠ¹ì¸ ${approvedCount}ëª…)`;
              } else if (hasChangesRequested && approvedCount >= 2) {
                statusText = `ğŸ› ï¸ ìˆ˜ì • ìš”ì²­ ìˆìŒ (í˜„ì¬ ìŠ¹ì¸ ${approvedCount}ëª…)`;
              } else if (!hasChangesRequested && approvedCount >= 2) {
                statusText = `âœ… ë¨¸ì§€ ê°€ëŠ¥ (í˜„ì¬ ìŠ¹ì¸ ${approvedCount}ëª…)`;
              } else {
                statusText = `ğŸ‘€ ë¦¬ë·° í•„ìš” (í˜„ì¬ ìŠ¹ì¸ ${approvedCount}ëª…)`;
              }
            
              // âœ… ì¹´ë“œ(Embed)
              embeds.push({
                title: `D-0 | ${pr.title}`,
                url: pr.url,
                color: 0xF52606, // D-0 ë¼ë²¨ ìƒ‰(#f52606)
                fields: [
                  { name: "ìƒíƒœ", value: statusText, inline: false },
                  { name: "ì‘ì„±ì", value: pr.author, inline: true },
                  { name: "ìŠ¹ì¸", value: `${approvedCount}ëª…`, inline: true },
                  { name: "í˜¸ì¶œ", value: mentions ? mentions : "-", inline: false },
                ],
              });
            }
            
            // âœ… payload.jsonì„ embeds í˜•íƒœë¡œ ìƒì„±
            const payload = {
              content: "ğŸŒ¸ ì˜¤ëŠ˜ D-0 ë„ì°©í•œ PRì´ì—ìš”! ì§€ê¸ˆ í™•ì¸í•˜ë©´ ë”± ì¢‹ì•„ìš”",
              embeds,
            };
            
            fs.writeFileSync("payload.json", JSON.stringify(payload, null, 2), "utf8");
            core.setOutput("should_notify", "true");
            core.setOutput("d0_count", String(becameD0.length));

      - name: Notify Discord (D-0 reached PRs)
        if: steps.build.outputs.should_notify == 'true'
        env:
          DISCORD_WEBHOOK_PR: ${{ secrets.DISCORD_WEBHOOK_PR }}
        run: |
          curl -sS -H "Content-Type: application/json" -d @payload.json "$DISCORD_WEBHOOK_PR"

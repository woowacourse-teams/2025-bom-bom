name: Backend Prod Server CI/CD

on:
  push:
    branches:
      - server
  workflow_dispatch:
    inputs:
      version_tag:
        description: '배포할 버전 태그 (예: server-v1.0.0)'
        required: false
        type: string

jobs:
  build:
    outputs:
      version_tag: ${{ steps.version.outputs.tag }}
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./backend/bom-bom-server

    steps:
      - name: 코드 체크아웃
        id: checkout
        uses: actions/checkout@v4
        with:
          # 최소한의 히스토리만 가져오기
          fetch-depth: 1

      - name: 버전 태그 결정
        id: version
        run: |
          if [ -n "${{ github.event.inputs.version_tag }}" ]; then
            # 수동 입력된 버전 태그 사용
            VERSION_TAG="${{ github.event.inputs.version_tag }}"
            echo "수동 입력 버전: $VERSION_TAG"
          else
            # 최신 태그 확인 (server* 형식)
            git fetch --tags
            LATEST_TAG=$(git tag --list "server-*" --sort=-version:refname | head -1 || echo "server-v0.0.0")
            echo "최신 태그: $LATEST_TAG"

            # server-v1.2.3 형식 파싱
            if [[ "$LATEST_TAG" =~ ^server-v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
              MAJOR="${BASH_REMATCH[1]}"
              MINOR="${BASH_REMATCH[2]}"
              PATCH="${BASH_REMATCH[3]}"

              # PATCH 버전 자동 증가
              NEW_PATCH=$((PATCH + 1))
              VERSION_TAG="server-v${MAJOR}.${MINOR}.${NEW_PATCH}"

              echo "새 버전 생성: $LATEST_TAG → $VERSION_TAG"
            else
              # 태그가 없으면 server-v1.0.0으로 시작
              VERSION_TAG="server-v1.0.0"
              echo "새 버전 시작: $VERSION_TAG"
            fi

            # 새 태그 생성 및 푸시
            git tag $VERSION_TAG
            git push origin $VERSION_TAG
            echo "새 태그 $VERSION_TAG 생성 및 푸시 완료"
          fi

          echo "tag=$VERSION_TAG" >> $GITHUB_OUTPUT
          echo "최종 버전: $VERSION_TAG"

      - name: JDK 21 설정
        uses: actions/setup-java@v4
        with:
          java-version: 21
          distribution: temurin
          # Gradle 캐시 최적화
          cache: gradle

      - name: Gradle 캐시 복원
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: application.yml 생성 (Prod 환경)
        run: |
          echo "Create application.yml(prod) from secret"
          mkdir -p src/main/resources
          echo "${{ secrets.APPLICATION_PROD_PROPERTIES }}" > src/main/resources/application.yml
          
          echo "Create application.yml(test) from secret"
          mkdir -p src/test/resources
          echo "${{ secrets.APPLICATION_TEST_PROPERTIES }}" > src/test/resources/application.yml

      - name: JAR 빌드
        run: ./gradlew build --no-daemon

      - name: Docker Buildx 설정
        uses: docker/setup-buildx-action@v3
        with:
          # 단일 인스턴스 사용으로 CPU 절약
          driver-opts: |
            image=moby/buildkit:v0.12.0
            network=host

      - name: DockerHub 로그인
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Docker 이미지 빌드 및 푸시
        run: |
          if ! docker buildx inspect ci-builder &>/dev/null; then
            docker buildx create --use --name ci-builder
          else
            docker buildx use ci-builder
          fi
          
          VERSION_TAG="${{ steps.version.outputs.tag }}"
          
          docker buildx build \
            --platform linux/arm64,linux/amd64 \
            --cache-from=type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/bom-bom:buildcache \
            --cache-to=type=registry,ref=${{ secrets.DOCKERHUB_USERNAME }}/bom-bom:buildcache,mode=max \
            -t ${{ secrets.DOCKERHUB_USERNAME }}/bom-bom:${VERSION_TAG} \
            -t ${{ secrets.DOCKERHUB_USERNAME }}/bom-bom:prod \
            --push .
          
          echo "이미지 푸시 완료: ${VERSION_TAG}, prod"

  deploy:
    name: Production Server 배포
    needs: build
    runs-on: [ self-hosted, prod ]
    defaults:
      run:
        working-directory: ./backend/bom-bom-server
    # 배포 타임아웃 설정
    timeout-minutes: 10

    environment:
      name: production
      url: https://api.bombom.news

    steps:
      - name: 코드 체크아웃
        uses: actions/checkout@v4
        with:
          # 배포용으로는 최소한의 코드만
          fetch-depth: 1

      - name: DockerHub 로그인
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: .env file 생성
        run: |
          cat <<EOF > .env
          RDS_ENDPOINT=${{ secrets.PROD_RDS_ENDPOINT }}
          DATABASE=${{ secrets.PROD_DATABASE }}
          MYSQL_USER=${{ secrets.PROD_MYSQL_USER }}
          MYSQL_PASSWORD=${{ secrets.PROD_MYSQL_PASSWORD }}
          DOCKER_IMAGE=${{ secrets.DOCKERHUB_USERNAME }}/bom-bom:${{ needs.build.outputs.version_tag }}
          EOF
          echo "배포할 이미지: ${{ secrets.DOCKERHUB_USERNAME }}/bom-bom:${{ needs.build.outputs.version_tag }}"

      - name: 컨테이너 재실행 (CPU 최적화)
        run: |
          # 기존 컨테이너 정리
          sudo docker compose -f docker-compose-prod.yml down --remove-orphans --timeout 30
          
          # 새 컨테이너 시작 (CPU 제한 없이)
          sudo docker compose \
            -f docker-compose-prod.yml \
            --env-file .env \
            up -d --remove-orphans --pull=always
          echo "배포 완료!"

      - name: 헬스체크
        run: |
          echo "서비스 헬스체크 시작..."
          sleep 10
          for i in {1..5}; do
            if curl -v -f http://localhost/actuator/health > /dev/null; then
              echo "✅ 서비스 정상 동작"
              break
            else
              echo "⏳ 헬스체크 대기 중... ($i/5)"
              sleep 10
            fi
          done

      - name: Docker 리소스 정리 (CPU 절약)
        run: |
          # 오래된 리소스만 정리 (CPU 집약적 작업 최소화)
          sudo docker container prune -f --filter "until=48h"
          sudo docker image prune -f --filter "until=48h"
          sudo docker system prune -f --filter "until=24h"
